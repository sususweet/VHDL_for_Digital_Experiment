-- WARNING: Do NOT edit the input and output ports in this file in a text
-- editor if you plan to continue editing the block that represents it in
-- the Block Editor! File corruption is VERY likely to occur.

-- Copyright (C) 1991-2009 Altera Corporation
-- Your use of Altera Corporation's design tools, logic functions 
-- and other software and tools, and its AMPP partner logic 
-- functions, and any output files from any of the foregoing 
-- (including device programming or simulation files), and any 
-- associated documentation or information are expressly subject 
-- to the terms and conditions of the Altera Program License 
-- Subscription Agreement, Altera MegaCore Function License 
-- Agreement, or other applicable license agreement, including, 
-- without limitation, that your use is for the sole purpose of 
-- programming logic devices manufactured by Altera and sold by 
-- Altera or its authorized distributors.  Please refer to the 
-- applicable agreement for further details.


-- Generated by Quartus II Version 9.1 (Build Build 222 10/21/2009)
-- Created on Tue May 16 15:16:14 2017

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;
USE ieee.std_logic_arith.all;
--  Entity Declaration

ENTITY timer IS
	-- {{ALTERA_IO_BEGIN}} DO NOT REMOVE THIS LINE!
	PORT
	(
		CLK : IN STD_LOGIC;
		CLK_HIGH : IN STD_LOGIC;
		CLK_DBLE : IN STD_LOGIC;
		SET_TYPE : IN STD_LOGIC;
		SET_ITEM : IN STD_LOGIC;
		EN_ALARM : IN STD_LOGIC;
		EN_REPORT : IN STD_LOGIC;
		SEC0 : BUFFER STD_LOGIC_VECTOR(3 downto 0);
		SEC1 : BUFFER STD_LOGIC_VECTOR(3 downto 0);
		MIN0 : BUFFER STD_LOGIC_VECTOR(3 downto 0);
		MIN1 : BUFFER STD_LOGIC_VECTOR(3 downto 0);
		HOUR0 : BUFFER STD_LOGIC_VECTOR(3 downto 0);
		HOUR1 : BUFFER STD_LOGIC_VECTOR(3 downto 0);
		DOT0 : BUFFER STD_LOGIC;
		DOT1 : BUFFER STD_LOGIC;
		DOT2 : BUFFER STD_LOGIC;
		DOT3 : BUFFER STD_LOGIC;
		DOT4 : BUFFER STD_LOGIC;
		DOT5 : BUFFER STD_LOGIC;
		ALARM : OUT STD_LOGIC
	);
	-- {{ALTERA_IO_END}} DO NOT REMOVE THIS LINE!
	
END timer;


--  Architecture Body

ARCHITECTURE timer_architecture OF timer IS
	TYPE state IS (nowtime,sethour,setminute,alarmtime,setalarmhour,setalarmminute);
	SIGNAL cur_state : state := nowtime;
	SIGNAL TIME_SEC: INTEGER RANGE 0 TO 59 := 0;
	SIGNAL TIME_MIN: INTEGER RANGE 0 TO 59 := 0;
	SIGNAL TIME_HOUR: INTEGER RANGE 0 TO 23 := 0;
	
	SIGNAL CLK11: STD_LOGIC := '1';
	
	SIGNAL ALARM_MIN: INTEGER RANGE 0 TO 59 := 0;
	SIGNAL ALARM_HOUR: INTEGER RANGE 0 TO 23 := 12;
	SIGNAL DOTARRAY:std_logic_vector(5 DOWNTO 0);
BEGIN
	--Setting mode--
	PROCESS(SET_TYPE)
	BEGIN
		IF(RISING_EDGE(SET_TYPE)) THEN
			CASE cur_state IS 
				WHEN nowtime =>
					cur_state <= sethour;
				WHEN sethour =>
					cur_state <= setminute;
				WHEN setminute =>
					cur_state <= setalarmhour;
				WHEN setalarmhour =>
					cur_state <= setalarmminute;	
				WHEN setalarmminute =>
					cur_state <= alarmtime;
				WHEN alarmtime =>
					cur_state <= nowtime;
			END CASE;
		END IF;
	END PROCESS;
	--Setting mode end--

	PROCESS(CLK_DBLE,SET_ITEM)
	VARIABLE TIME_COUNT :integer range 0 to 1;
	
	BEGIN
		IF(RISING_EDGE(CLK_DBLE)) THEN
			IF (TIME_COUNT = 1) THEN
				TIME_COUNT := 0;
				IF (cur_state /= sethour AND cur_state /= setminute) THEN
					IF (TIME_SEC = 59) THEN
						TIME_SEC <= 0;
						TIME_MIN <= TIME_MIN + 1;
						IF (TIME_MIN = 59) THEN
							TIME_MIN <= 0;
							TIME_HOUR <= TIME_HOUR + 1;
							IF (TIME_HOUR = 23) THEN
								TIME_HOUR <= 0;
							ELSE
								TIME_HOUR <= TIME_HOUR + 1;
							END IF;
						ELSE
							TIME_MIN <= TIME_MIN + 1;
						END IF;
					ELSE 
						TIME_SEC <= TIME_SEC+1;
					END IF;		
				END IF;	
			ELSE
				TIME_COUNT := TIME_COUNT + 1;
			END IF;

			
			IF(CLK11='0' AND SET_ITEM='1') THEN
				CASE cur_state IS 
					WHEN sethour =>
							TIME_HOUR <= TIME_HOUR + 1;
							IF (TIME_HOUR = 23) THEN
								TIME_HOUR <= 0;
							END IF;
						
					WHEN setminute =>
						--IF (SET_ITEM = '0') THEN
							TIME_MIN <= TIME_MIN + 1;
							IF (TIME_MIN = 59) THEN
								TIME_MIN <= 0;
							END IF;
						--END IF;
					WHEN setalarmhour =>
						--IF (SET_ITEM = '0') THEN
							ALARM_HOUR <= ALARM_HOUR + 1;
							IF (ALARM_HOUR = 23) THEN
								ALARM_HOUR <= 0;
							END IF;
						--END IF;
					WHEN setalarmminute =>
						--IF (SET_ITEM = '0') THEN
							ALARM_MIN <= ALARM_MIN + 1;
							IF (ALARM_MIN = 59) THEN
								ALARM_MIN <= 0;
							END IF;
						--END IF;
					WHEN OTHERS => NULL;
				END CASE;
				CLK11 <= '1';
			ELSIF (CLK11='1' AND SET_ITEM='0') THEN
				CLK11 <= '0';
			ELSIF (CLK11='0' AND SET_ITEM='0') THEN
				CASE cur_state IS 
					WHEN sethour =>
							TIME_HOUR <= TIME_HOUR + 1;
							IF (TIME_HOUR = 23) THEN
								TIME_HOUR <= 0;
							END IF;
						
					WHEN setminute =>
						--IF (SET_ITEM = '0') THEN
							TIME_MIN <= TIME_MIN + 1;
							IF (TIME_MIN = 59) THEN
								TIME_MIN <= 0;
							END IF;
						--END IF;
					WHEN setalarmhour =>
						--IF (SET_ITEM = '0') THEN
							ALARM_HOUR <= ALARM_HOUR + 1;
							IF (ALARM_HOUR = 23) THEN
								ALARM_HOUR <= 0;
							END IF;
						--END IF;
					WHEN setalarmminute =>
						--IF (SET_ITEM = '0') THEN
							ALARM_MIN <= ALARM_MIN + 1;
							IF (ALARM_MIN = 59) THEN
								ALARM_MIN <= 0;
							END IF;
						--END IF;
					WHEN OTHERS => NULL;
				END CASE;
			END IF;
		END IF;
	END PROCESS;

	PROCESS(CLK_DBLE,EN_ALARM)
	VARIABLE TWINKLE: Boolean := FALSE;
	BEGIN
		IF(RISING_EDGE(CLK_DBLE)) THEN
			CASE cur_state IS 
				WHEN nowtime =>
					SEC0 <= conv_std_logic_vector(TIME_SEC rem 10,4);
					SEC1 <= conv_std_logic_vector(TIME_SEC/10 rem 10,4);
					MIN0 <= conv_std_logic_vector(TIME_MIN rem 10,4);
					MIN1 <= conv_std_logic_vector(TIME_MIN/10 rem 10,4);
					HOUR0 <= conv_std_logic_vector(TIME_HOUR rem 10,4);
					HOUR1 <= conv_std_logic_vector(TIME_HOUR/10 rem 10,4);
					IF (TWINKLE = FALSE) THEN
						DOTARRAY <= "101011";
						TWINKLE := TRUE;
					ELSE 
						DOTARRAY <= "111111";
						TWINKLE := FALSE;
					END IF;
				WHEN sethour =>
					SEC0 <= conv_std_logic_vector(TIME_SEC rem 10,4);
					SEC1 <= conv_std_logic_vector(TIME_SEC/10 rem 10,4);
					MIN0 <= conv_std_logic_vector(TIME_MIN rem 10,4);
					MIN1 <= conv_std_logic_vector(TIME_MIN/10 rem 10,4);
					DOTARRAY <= "101011";
					IF (TWINKLE = FALSE) THEN
						HOUR0 <= "1111";
						HOUR1 <= "1111";
						TWINKLE := TRUE;
					ELSE 
						HOUR0 <= conv_std_logic_vector(TIME_HOUR rem 10,4);
						HOUR1 <= conv_std_logic_vector(TIME_HOUR/10 rem 10,4);
						TWINKLE := FALSE;
					END IF;
					
				WHEN setminute =>
					SEC0 <= conv_std_logic_vector(TIME_SEC rem 10,4);
					SEC1 <= conv_std_logic_vector(TIME_SEC/10 rem 10,4);
					HOUR0 <= conv_std_logic_vector(TIME_HOUR rem 10,4);
					HOUR1 <= conv_std_logic_vector(TIME_HOUR/10 rem 10,4);
					DOTARRAY <= "101011";
					IF (TWINKLE = FALSE) THEN
						MIN0 <= "1111";
						MIN1 <= "1111";
						TWINKLE := TRUE;
					ELSE 
						MIN0 <= conv_std_logic_vector(TIME_MIN rem 10,4);
						MIN1 <= conv_std_logic_vector(TIME_MIN/10 rem 10,4);
						TWINKLE := FALSE;
					END IF;
				
				WHEN alarmtime =>
					IF (EN_ALARM = '1') THEN
						SEC0 <= "1111";
						SEC1 <= "1111";
					ELSE 
						SEC0 <= "1010";
						SEC1 <= "1010";
					END IF;
					DOTARRAY <= "101111";
					MIN0 <= conv_std_logic_vector(ALARM_MIN rem 10,4);
					MIN1 <= conv_std_logic_vector(ALARM_MIN/10 rem 10,4);
					HOUR0 <= conv_std_logic_vector(ALARM_HOUR rem 10,4);
					HOUR1 <= conv_std_logic_vector(ALARM_HOUR/10 rem 10,4);
					
				WHEN setalarmhour =>
					IF (EN_ALARM = '1') THEN
						SEC0 <= "1111";
						SEC1 <= "1111";
					ELSE 
						SEC0 <= "1010";
						SEC1 <= "1010";
					END IF;
					
					DOTARRAY <= "101111";
					MIN0 <= conv_std_logic_vector(ALARM_MIN rem 10,4);
					MIN1 <= conv_std_logic_vector(ALARM_MIN/10 rem 10,4);
					
					IF (TWINKLE = FALSE) THEN
						HOUR0 <= "1111";
						HOUR1 <= "1111";
						TWINKLE := TRUE;
					ELSE 
						HOUR0 <= conv_std_logic_vector(ALARM_HOUR rem 10,4);
						HOUR1 <= conv_std_logic_vector(ALARM_HOUR/10 rem 10,4);
						TWINKLE := FALSE;
					END IF;
					
				WHEN setalarmminute =>
					IF (EN_ALARM = '1') THEN
						SEC0 <= "1111";
						SEC1 <= "1111";
					ELSE 
						SEC0 <= "1010";
						SEC1 <= "1010";
					END IF;
					DOTARRAY <= "101111";
					HOUR0 <= conv_std_logic_vector(ALARM_HOUR rem 10,4);
					HOUR1 <= conv_std_logic_vector(ALARM_HOUR/10 rem 10,4);
					
					IF (TWINKLE = FALSE) THEN
						MIN0 <= "1111";
						MIN1 <= "1111";
						TWINKLE := TRUE;
					ELSE 
						MIN0 <= conv_std_logic_vector(ALARM_MIN rem 10,4);
						MIN1 <= conv_std_logic_vector(ALARM_MIN/10 rem 10,4);
						TWINKLE := FALSE;
					END IF;
			END CASE;
			DOT5 <= DOTARRAY(5);
			DOT4 <= DOTARRAY(4);
			DOT3 <= DOTARRAY(3);
			DOT2 <= DOTARRAY(2);			
			DOT1 <= DOTARRAY(1);
			DOT0 <= DOTARRAY(0);
		END IF;
	END PROCESS;

	PROCESS(CLK,TIME_SEC,TIME_MIN,TIME_HOUR,ALARM_MIN,ALARM_HOUR,EN_ALARM,EN_REPORT,CLK_HIGH,cur_state)
	BEGIN
	IF(cur_state /= sethour AND cur_state /= setminute) THEN
		IF (EN_REPORT = '0' OR EN_ALARM = '0') THEN
			IF (EN_REPORT = '0' AND TIME_MIN = 59 AND TIME_SEC>=56 AND CLK='1')THEN
				ALARM <= '1';
			ELSIF (EN_REPORT = '0' AND TIME_MIN = 0 AND TIME_SEC =0 AND CLK='1')THEN
				ALARM <= CLK_HIGH;
			ELSIF (EN_ALARM = '0' AND TIME_MIN = ALARM_MIN AND TIME_HOUR = ALARM_HOUR AND CLK='1') THEN
				ALARM <= '1';
			ELSE 
				ALARM <= '0';
			END IF;
		ELSE 
			ALARM <= '0';
		END IF;		
	END IF;
	END PROCESS;
END timer_architecture;

-- WARNING: Do NOT edit the input and output ports in this file in a text
-- editor if you plan to continue editing the block that represents it in
-- the Block Editor! File corruption is VERY likely to occur.

-- Copyright (C) 1991-2009 Altera Corporation
-- Your use of Altera Corporation's design tools, logic functions 
-- and other software and tools, and its AMPP partner logic 
-- functions, and any output files from any of the foregoing 
-- (including device programming or simulation files), and any 
-- associated documentation or information are expressly subject 
-- to the terms and conditions of the Altera Program License 
-- Subscription Agreement, Altera MegaCore Function License 
-- Agreement, or other applicable license agreement, including, 
-- without limitation, that your use is for the sole purpose of 
-- programming logic devices manufactured by Altera and sold by 
-- Altera or its authorized distributors.  Please refer to the 
-- applicable agreement for further details.


-- Generated by Quartus II Version 9.1 (Build Build 222 10/21/2009)
-- Created on Tue May 16 15:16:14 2017

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;
USE ieee.std_logic_arith.all;
--  Entity Declaration

ENTITY timer IS
	-- {{ALTERA_IO_BEGIN}} DO NOT REMOVE THIS LINE!
	PORT
	(
		CLK : IN STD_LOGIC;
		SET_TYPE : IN STD_LOGIC;
		SET_ITEM : IN STD_LOGIC;
		EN_ALARM : IN STD_LOGIC;
		EN_REPORT : IN STD_LOGIC;
		SEC0 : BUFFER STD_LOGIC_VECTOR(3 downto 0);
		SEC1 : BUFFER STD_LOGIC_VECTOR(3 downto 0);
		MIN0 : BUFFER STD_LOGIC_VECTOR(3 downto 0);
		MIN1 : BUFFER STD_LOGIC_VECTOR(3 downto 0);
		HOUR0 : BUFFER STD_LOGIC_VECTOR(3 downto 0);
		HOUR1 : BUFFER STD_LOGIC_VECTOR(3 downto 0);
		ALARM : OUT STD_LOGIC
	);
	-- {{ALTERA_IO_END}} DO NOT REMOVE THIS LINE!
	
END timer;


--  Architecture Body

ARCHITECTURE timer_architecture OF timer IS
	TYPE state IS (nowtime,sethour,setminute,alarmtime,setalarmhour,setalarmminute);
	SIGNAL cur_state : state;
	SIGNAL TIME_SEC: INTEGER RANGE 0 TO 59 := 0;
	SIGNAL TIME_MIN: INTEGER RANGE 0 TO 59 := 0;
	SIGNAL TIME_HOUR: INTEGER RANGE 0 TO 23 := 0;
	SIGNAL ALARM_MIN: INTEGER RANGE 0 TO 59 := 0;
	SIGNAL ALARM_HOUR: INTEGER RANGE 0 TO 23 := 0;
BEGIN
	--Setting mode--
	PROCESS(SET_TYPE)
	BEGIN
		IF(RISING_EDGE(SET_TYPE)) THEN
			CASE cur_state IS 
				WHEN nowtime =>
					cur_state <= sethour;
				WHEN sethour =>
					cur_state <= setminute;
				WHEN setminute =>
					cur_state <= setalarmhour;
				WHEN setalarmhour =>
					cur_state <= setalarmminute;	
				WHEN setalarmminute =>
					cur_state <= alarmtime;
				WHEN alarmtime =>
					cur_state <= nowtime;
			END CASE;
		END IF;
	END PROCESS;
	--Setting mode end--

	PROCESS(CLK,SET_ITEM)
	BEGIN
		IF(RISING_EDGE(CLK)) THEN
			CASE cur_state IS 
				WHEN sethour =>
					IF (SET_ITEM = '0') THEN
						TIME_HOUR <= TIME_HOUR + 1;
						IF (TIME_HOUR = 24) THEN
							TIME_HOUR <= 0;
						END IF;
					END IF;
				WHEN setminute =>
					IF (SET_ITEM = '0') THEN
						TIME_MIN <= TIME_MIN + 1;
						IF (TIME_MIN = 60) THEN
							TIME_MIN <= 0;
						END IF;
					END IF;
				WHEN setalarmhour =>
					IF (SET_ITEM = '0') THEN
						ALARM_HOUR <= ALARM_HOUR + 1;
						IF (ALARM_HOUR = 24) THEN
							ALARM_HOUR <= 0;
						END IF;
					END IF;
				WHEN setalarmminute =>
					IF (SET_ITEM = '0') THEN
						ALARM_MIN <= ALARM_MIN + 1;
						IF (ALARM_MIN = 60) THEN
							ALARM_MIN <= 0;
						END IF;
					END IF;
				WHEN OTHERS => NULL;
			END CASE;
			IF (cur_state /= sethour AND cur_state /= setminute) THEN
				IF (TIME_SEC = 59) THEN
					TIME_SEC <= 0;
					TIME_MIN <= TIME_MIN + 1;
					IF (TIME_MIN = 59) THEN
						TIME_MIN <= 0;
						TIME_HOUR <= TIME_HOUR + 1;
						IF (TIME_HOUR = 23) THEN
							TIME_HOUR <= 0;
						ELSE
							TIME_HOUR <= TIME_HOUR + 1;
						END IF;
					ELSE
						TIME_MIN <= TIME_MIN + 1;
					END IF;
				ELSE 
					TIME_SEC <= TIME_SEC+1;
				END IF;		
			END IF;	
		END IF;
	END PROCESS;

	PROCESS(CLK)
	VARIABLE TWINKLE: Boolean := FALSE;
	BEGIN
		IF(RISING_EDGE(CLK)) THEN
			CASE cur_state IS 
				WHEN nowtime =>
					SEC0 <= conv_std_logic_vector(TIME_SEC rem 10,4);
					SEC1 <= conv_std_logic_vector(TIME_SEC/10 rem 10,4);
					MIN0 <= conv_std_logic_vector(TIME_MIN rem 10,4);
					MIN1 <= conv_std_logic_vector(TIME_MIN/10 rem 10,4);
					HOUR0 <= conv_std_logic_vector(TIME_HOUR rem 10,4);
					HOUR1 <= conv_std_logic_vector(TIME_HOUR/10 rem 10,4);
				WHEN sethour =>
					SEC0 <= conv_std_logic_vector(TIME_SEC rem 10,4);
					SEC1 <= conv_std_logic_vector(TIME_SEC/10 rem 10,4);
					MIN0 <= conv_std_logic_vector(TIME_MIN rem 10,4);
					MIN1 <= conv_std_logic_vector(TIME_MIN/10 rem 10,4);
					IF (TWINKLE = FALSE) THEN
						HOUR0 <= "1111";
						HOUR1 <= "1111";
						TWINKLE := TRUE;
					ELSE 
						HOUR0 <= conv_std_logic_vector(TIME_HOUR rem 10,4);
						HOUR1 <= conv_std_logic_vector(TIME_HOUR/10 rem 10,4);
						TWINKLE := FALSE;
					END IF;
					
				WHEN setminute =>
					SEC0 <= conv_std_logic_vector(TIME_SEC rem 10,4);
					SEC1 <= conv_std_logic_vector(TIME_SEC/10 rem 10,4);
					HOUR0 <= conv_std_logic_vector(TIME_HOUR rem 10,4);
					HOUR1 <= conv_std_logic_vector(TIME_HOUR/10 rem 10,4);
					IF (TWINKLE = FALSE) THEN
						MIN0 <= "1111";
						MIN1 <= "1111";
						TWINKLE := TRUE;
					ELSE 
						MIN0 <= conv_std_logic_vector(TIME_MIN rem 10,4);
						MIN1 <= conv_std_logic_vector(TIME_MIN/10 rem 10,4);
						TWINKLE := FALSE;
					END IF;
				
				WHEN alarmtime =>
					IF (EN_ALARM = '0') THEN
						SEC0 <= "1111";
						SEC1 <= "1111";
					ELSE 
						SEC0 <= "1010";
						SEC1 <= "1010";
					END IF;
					MIN0 <= conv_std_logic_vector(ALARM_MIN rem 10,4);
					MIN1 <= conv_std_logic_vector(ALARM_MIN/10 rem 10,4);
					HOUR0 <= conv_std_logic_vector(ALARM_HOUR rem 10,4);
					HOUR1 <= conv_std_logic_vector(ALARM_HOUR/10 rem 10,4);
					
				WHEN setalarmhour =>
					IF (EN_ALARM = '0') THEN
						SEC0 <= "1111";
						SEC1 <= "1111";
					ELSE 
						SEC0 <= "1010";
						SEC1 <= "1010";
					END IF;
					MIN0 <= conv_std_logic_vector(ALARM_MIN rem 10,4);
					MIN1 <= conv_std_logic_vector(ALARM_MIN/10 rem 10,4);
					
					IF (TWINKLE = FALSE) THEN
						HOUR0 <= "1111";
						HOUR1 <= "1111";
						TWINKLE := TRUE;
					ELSE 
						HOUR0 <= conv_std_logic_vector(ALARM_HOUR rem 10,4);
						HOUR1 <= conv_std_logic_vector(ALARM_HOUR/10 rem 10,4);
						TWINKLE := FALSE;
					END IF;
					
				WHEN setalarmminute =>
					IF (EN_ALARM = '0') THEN
						SEC0 <= "1111";
						SEC1 <= "1111";
					ELSE 
						SEC0 <= "1010";
						SEC1 <= "1010";
					END IF;
					HOUR0 <= conv_std_logic_vector(ALARM_HOUR rem 10,4);
					HOUR1 <= conv_std_logic_vector(ALARM_HOUR/10 rem 10,4);
					
					IF (TWINKLE = FALSE) THEN
						MIN0 <= "1111";
						MIN1 <= "1111";
						TWINKLE := TRUE;
					ELSE 
						MIN0 <= conv_std_logic_vector(ALARM_MIN rem 10,4);
						MIN1 <= conv_std_logic_vector(ALARM_MIN/10 rem 10,4);
						TWINKLE := FALSE;
					END IF;
			END CASE;
		END IF;
	END PROCESS;

	PROCESS(CLK,TIME_SEC,TIME_MIN,TIME_HOUR,ALARM_MIN,ALARM_HOUR,EN_ALARM,EN_REPORT)
	BEGIN
		IF (TIME_MIN = 59 AND TIME_SEC>=56 AND CLK='0' AND EN_REPORT = '0')THEN
			--IF (SET_HOUR = '1' AND SET_MIN = '1') THEN
				ALARM <= '1';
			--ELSE 
				--ALARM <= '0';
			--END IF;
		ELSIF (TIME_MIN = 0 AND TIME_SEC =0 AND CLK='0' AND EN_REPORT = '0')THEN
			ALARM <= '1';
		ELSE
			IF (EN_ALARM = '0') THEN
				IF (TIME_MIN = ALARM_MIN AND TIME_HOUR = ALARM_HOUR AND CLK='0')THEN
					ALARM <= '0';
				ELSE
					ALARM <= '1';
				END IF;
			ELSE
				ALARM <= '0';
			END IF;
		END IF;
	END PROCESS;
END timer_architecture;
